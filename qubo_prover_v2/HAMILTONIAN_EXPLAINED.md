# 哈密顿量构造 - 通俗易懂的解释

## 🧒 给三岁小孩的解释

### 想象一个游戏：找到最低的山谷

你在一个有很多山和谷的地方，你的任务是找到**最低的谷底**。

---

## 第一步：什么是哈密顿量？

**哈密顿量 = 一个打分系统**

- 每个位置都有一个"高度分数"
- 分数越低 = 越好
- 我们要找分数最低的位置

---

## 第二步：我们的"位置"是什么？

**位置 = 变量的赋值**

比如：
- P = 真 或 假
- Q = 真 或 假

所以有 4 个可能的"位置"：
1. P=真, Q=真
2. P=真, Q=假
3. P=假, Q=真
4. P=假, Q=假

---

## 第三步：如何给每个位置打分？

**核心规则：如果违反了规定，就加罚分！**

### 🎯 规定 1：公理必须是真的

**例子：** 公理说 "P 是真的"

- 如果 P=真 → 罚分 0（很好！）
- 如果 P=假 → 罚分 100（很糟糕！）

**公式：** `罚分 = 100 × (1 - P)²`
- 当 P=1（真）时：100 × (1-1)² = 0
- 当 P=0（假）时：100 × (1-0)² = 100

---

### 🎯 规定 2：目标必须是真的

**例子：** 目标是 "Q 是真的"

- 如果 Q=真 → 罚分 0
- 如果 Q=假 → 罚分 100

**公式：** `罚分 = 100 × (1 - Q)²`

---

### 🎯 规定 3：逻辑关系必须正确

#### 例子 A：蕴涵 (P→Q)

**真值表：**
```
P | Q | P→Q 应该是
0 | 0 |   1  (真)
0 | 1 |   1  (真)
1 | 0 |   0  (假) ← 这是唯一错误的情况
1 | 1 |   1  (真)
```

**数学公式：** P→Q = 1 - P + P×Q

验证：
- 当 P=0, Q=0: 1 - 0 + 0×0 = 1 ✓
- 当 P=0, Q=1: 1 - 0 + 0×1 = 1 ✓
- 当 P=1, Q=0: 1 - 1 + 1×0 = 0 ✓
- 当 P=1, Q=1: 1 - 1 + 1×1 = 1 ✓

**QUBO 约束：** `罚分 = 10 × (Imp_P_Q - 1 + P - P×Q)²`

---

#### 例子 B：否定 (~P)

**规则：** ~P 和 P 必须相反

- 如果 P=真，那么 ~P=假
- 如果 P=假，那么 ~P=真

**数学公式：** ~P = 1 - P

**QUBO 约束：** `罚分 = 10 × (Not_P + P - 1)²`

验证：
- 当 P=1, Not_P=0: (0 + 1 - 1)² = 0 ✓
- 当 P=0, Not_P=1: (1 + 0 - 1)² = 0 ✓
- 当 P=1, Not_P=1: (1 + 1 - 1)² = 1 ✗（矛盾！）

---

#### 例子 C：合取 (P∧Q)

**规则：** P∧Q 只有在 P 和 Q 都为真时才为真

**数学公式：** P∧Q = P × Q

**QUBO 约束：** `罚分 = 10 × (And_P_Q - P×Q)²`

---

#### 例子 D：析取 (P∨Q)

**规则：** P∨Q 只要 P 或 Q 有一个为真就为真

**数学公式：** P∨Q = P + Q - P×Q

**QUBO 约束：** `罚分 = 10 × (Or_P_Q - P - Q + P×Q)²`

---

## 第四步：总分数（哈密顿量）

**总分 = 所有罚分加起来**

```
H = 100×(公理1的罚分) 
  + 100×(公理2的罚分) 
  + 100×(目标的罚分)
  + 10×(逻辑关系1的罚分)
  + 10×(逻辑关系2的罚分)
  + 5×(推理规则的罚分)
  + ...
```

### 惩罚系数的意义

- **100** - 非常重要（公理和目标必须满足）
- **10** - 重要（逻辑结构必须正确）
- **5** - 有帮助（推理规则提供指导）

---

## 第五步：找到最低分

**模拟退火 = 一个聪明的搜索方法**

就像一个小球在山谷里滚动：
1. **开始时**：随机跳来跳去（探索不同的可能）
2. **慢慢地**：只往低处走（收敛到好的解）
3. **最后**：停在最低的谷底（找到最优解）

---

## 🎯 完整例子：证明 P, P→Q ⊢ Q

### 输入
- 公理1: P
- 公理2: P→Q
- 目标: Q

### 构造哈密顿量

```
H = 100×(1-P)²              ← 强制 P=1
  + 100×(1-Imp_P_Q)²        ← 强制 P→Q=1
  + 100×(1-Q)²              ← 强制 Q=1
  + 10×(Imp_P_Q-1+P-P×Q)²   ← 确保 P→Q 的逻辑正确
```

### 测试所有可能的位置

#### 位置1: P=0, Q=0
```
H = 100×(1-0)² + 100×(1-1)² + 100×(1-0)² + 10×(1-1+0-0)²
  = 100×1 + 100×0 + 100×1 + 10×0
  = 200 (很高！)
```

#### 位置2: P=0, Q=1
```
H = 100×(1-0)² + 100×(1-1)² + 100×(1-1)² + 10×(1-1+0-0)²
  = 100×1 + 100×0 + 100×0 + 10×0
  = 100 (还是高)
```

#### 位置3: P=1, Q=0
```
H = 100×(1-1)² + 100×(1-0)² + 100×(1-0)² + 10×(0-1+1-0)²
  = 100×0 + 100×1 + 100×1 + 10×0
  = 200 (很高！)
```

#### 位置4: P=1, Q=1
```
H = 100×(1-1)² + 100×(1-1)² + 100×(1-1)² + 10×(1-1+1-1)²
  = 100×0 + 100×0 + 100×0 + 10×0
  = 0 (最低！✓)
```

**结论：** 最低分是 P=1, Q=1，证明成功！

---

## 🔍 为什么错误的证明会被拒绝？

### 错误例子：P, P→Q ⊢ ~Q

#### 尝试的赋值：P=1, Q=0, ~Q=1

让我们计算分数：

```
H = 100×(1-1)²              ← P=1，罚分=0 ✓
  + 100×(1-1)²              ← Imp_P_Q=1（强制），罚分=0 ✓
  + 100×(1-1)²              ← Not_Q=1（强制），罚分=0 ✓
  + 10×(1-1+1-1×0)²         ← Imp_P_Q 的结构约束
  = 10×(1-1+1-0)²
  = 10×1²
  = 10 (有罚分！)
```

**问题：** 虽然能量不是 0，但采样器可能找到这个解。

**解决方案：** 在验证阶段检查结构约束！

#### 验证检查

```python
# 检查：如果 P=1 且 P→Q=1，那么 Q 必须=1
if P == 1 and Imp_P_Q == 1:
    if Q != 1:
        return False, "蕴涵约束违反"
```

在这个例子中：
- P=1 ✓
- Imp_P_Q=1 ✓
- Q=0 ✗

**结论：** 验证失败，证明被拒绝！

---

## 📊 总结

### 哈密顿量的三个组成部分

| 组件 | 惩罚系数 | 作用 |
|------|---------|------|
| **公理约束** | 100 | 强制公理为真 |
| **目标约束** | 100 | 强制目标为真 |
| **结构约束** | 10 | 确保逻辑运算符的语义正确 |
| **推理规则** | 5 | 提供推理指导（可选） |

### 为什么这个方法有效？

1. **能量最小化 = 满足所有约束**
   - 能量为 0 = 完美满足所有约束
   - 能量 > 0 = 有约束被违反

2. **惩罚系数控制优先级**
   - 高惩罚 = 必须满足
   - 低惩罚 = 最好满足

3. **模拟退火找到最优解**
   - 探索所有可能的赋值
   - 收敛到能量最低的解

4. **验证确保正确性**
   - 检查结构约束的一致性
   - 拒绝逻辑矛盾的解

---

## 🎓 进阶理解

### QUBO 的数学形式

```
E(x) = Σ Q_ij * x_i * x_j + offset
```

其中：
- `x_i, x_j` 是二元变量（0 或 1）
- `Q_ij` 是系数矩阵
- `offset` 是常数项

### 从约束到 QUBO

**约束：** `(A + B - 1)² = 0`

**展开：**
```
(A + B - 1)²
= A² + B² + 1 + 2AB - 2A - 2B
= A + B + 1 + 2AB - 2A - 2B    (因为 A² = A, B² = B)
= 2AB - A - B + 1
```

**QUBO 项：**
- 二次项：`2AB`
- 线性项：`-A`, `-B`
- 常数项：`1`

---

**最后更新：** 2025-11-04
**版本：** 2.1.1

